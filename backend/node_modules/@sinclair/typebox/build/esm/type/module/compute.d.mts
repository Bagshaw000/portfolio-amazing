import { Ensure, Evaluate } from '../helpers/index.mjs';
import { type TSchema } from '../schema/index.mjs';
import { type TArray } from '../array/index.mjs';
import { type TAwaited } from '../awaited/index.mjs';
import { type TAsyncIterator } from '../async-iterator/index.mjs';
import { TComputed } from '../computed/index.mjs';
import { type TConstructor } from '../constructor/index.mjs';
import { type TIndex } from '../indexed/index.mjs';
import { type TFunction } from '../function/index.mjs';
import { type TIntersect, type TIntersectEvaluated } from '../intersect/index.mjs';
import { type TIterator } from '../iterator/index.mjs';
import { type TKeyOf } from '../keyof/index.mjs';
import { type TObject, type TProperties } from '../object/index.mjs';
import { type TOmit } from '../omit/index.mjs';
import { type TPick } from '../pick/index.mjs';
import { type TNever } from '../never/index.mjs';
import { TPartial } from '../partial/index.mjs';
import { type TRecordOrObject } from '../record/index.mjs';
import { type TRef } from '../ref/index.mjs';
import { TRequired } from '../required/index.mjs';
import { type TTuple } from '../tuple/index.mjs';
import { type TUnion, type TUnionEvaluated } from '../union/index.mjs';
type TDerefParameters<ModuleProperties extends TProperties, Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? Left extends TRef<infer Key extends string> ? TDerefParameters<ModuleProperties, Right, [...Result, TDeref<ModuleProperties, Key>]> : TDerefParameters<ModuleProperties, Right, [...Result, TFromType<ModuleProperties, Left>]> : Result);
type TDeref<ModuleProperties extends TProperties, Ref extends string, Result extends TSchema = (Ref extends keyof ModuleProperties ? ModuleProperties[Ref] extends TRef<infer Ref2 extends string> ? TDeref<ModuleProperties, Ref2> : TFromType<ModuleProperties, ModuleProperties[Ref]> : TNever)> = Result;
type TFromAwaited<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TAwaited<T0> : never);
type TFromIndex<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TIndex<T0, T1> : never);
type TFromKeyOf<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TKeyOf<T0> : never);
type TFromPartial<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TPartial<T0> : never);
type TFromOmit<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TOmit<T0, T1> : never);
type TFromPick<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TPick<T0, T1> : never);
type TFromRecord<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema, infer T1 extends TSchema] ? TRecordOrObject<T0, T1> : never);
type TFromRequired<Parameters extends TSchema[]> = (Parameters extends [infer T0 extends TSchema] ? TRequired<T0> : never);
type TFromComputed<ModuleProperties extends TProperties, Target extends string, Parameters extends TSchema[], Dereferenced extends TSchema[] = TDerefParameters<ModuleProperties, Parameters>> = (Target extends 'Awaited' ? TFromAwaited<Dereferenced> : Target extends 'Index' ? TFromIndex<Dereferenced> : Target extends 'KeyOf' ? TFromKeyOf<Dereferenced> : Target extends 'Partial' ? TFromPartial<Dereferenced> : Target extends 'Omit' ? TFromOmit<Dereferenced> : Target extends 'Pick' ? TFromPick<Dereferenced> : Target extends 'Record' ? TFromRecord<Dereferenced> : Target extends 'Required' ? TFromRequired<Dereferenced> : TNever);
type TFromObject<ModuleProperties extends TProperties, Properties extends TProperties> = Ensure<TObject<Evaluate<{
    [Key in keyof Properties]: TFromType<ModuleProperties, Properties[Key]>;
}>>>;
type TFromConstructor<ModuleProperties extends TProperties, Parameters extends TSchema[], InstanceType extends TSchema> = (TConstructor<TFromRest<ModuleProperties, Parameters>, TFromType<ModuleProperties, InstanceType>>);
type TFromFunction<ModuleProperties extends TProperties, Parameters extends TSchema[], ReturnType extends TSchema> = Ensure<Ensure<TFunction<TFromRest<ModuleProperties, Parameters>, TFromType<ModuleProperties, ReturnType>>>>;
type TFromTuple<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TTuple<TFromRest<ModuleProperties, Types>>>);
type TFromIntersect<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TIntersectEvaluated<TFromRest<ModuleProperties, Types>>>);
type TFromUnion<ModuleProperties extends TProperties, Types extends TSchema[]> = (Ensure<TUnionEvaluated<TFromRest<ModuleProperties, Types>>>);
type TFromArray<ModuleProperties extends TProperties, Type extends TSchema> = (Ensure<TArray<TFromType<ModuleProperties, Type>>>);
type TFromAsyncIterator<ModuleProperties extends TProperties, Type extends TSchema> = (TAsyncIterator<TFromType<ModuleProperties, Type>>);
type TFromIterator<ModuleProperties extends TProperties, Type extends TSchema> = (TIterator<TFromType<ModuleProperties, Type>>);
type TFromRest<ModuleProperties extends TProperties, Types extends TSchema[], Result extends TSchema[] = []> = (Types extends [infer Left extends TSchema, ...infer Right extends TSchema[]] ? TFromRest<ModuleProperties, Right, [...Result, TFromType<ModuleProperties, Left>]> : Result);
export type TFromType<ModuleProperties extends TProperties, Type extends TSchema> = (Type extends TComputed<infer T extends string, infer S extends TSchema[]> ? TFromComputed<ModuleProperties, T, S> : Type extends TObject<infer S extends TProperties> ? TFromObject<ModuleProperties, S> : Type extends TConstructor<infer S extends TSchema[], infer R extends TSchema> ? TFromConstructor<ModuleProperties, S, R> : Type extends TFunction<infer S extends TSchema[], infer R extends TSchema> ? TFromFunction<ModuleProperties, S, R> : Type extends TTuple<infer S extends TSchema[]> ? TFromTuple<ModuleProperties, S> : Type extends TIntersect<infer S extends TSchema[]> ? TFromIntersect<ModuleProperties, S> : Type extends TUnion<infer S extends TSchema[]> ? TFromUnion<ModuleProperties, S> : Type extends TArray<infer S extends TSchema> ? TFromArray<ModuleProperties, S> : Type extends TAsyncIterator<infer S extends TSchema> ? TFromAsyncIterator<ModuleProperties, S> : Type extends TIterator<infer S extends TSchema> ? TFromIterator<ModuleProperties, S> : Type);
export declare function FromType<ModuleProperties extends TProperties, Type extends TSchema>(moduleProperties: ModuleProperties, type: Type): TFromType<ModuleProperties, Type>;
export type TComputeType<ModuleProperties extends TProperties, Key extends PropertyKey> = (Key extends keyof ModuleProperties ? TFromType<ModuleProperties, ModuleProperties[Key]> : TNever);
export declare function ComputeType<ModuleProperties extends TProperties, Key extends PropertyKey>(moduleProperties: ModuleProperties, key: Key): TComputeType<ModuleProperties, Key>;
export type TComputeModuleProperties<ModuleProperties extends TProperties> = Evaluate<{
    [Key in keyof ModuleProperties]: TComputeType<ModuleProperties, Key>;
}>;
export declare function ComputeModuleProperties<ModuleProperties extends TProperties>(moduleProperties: ModuleProperties): TComputeModuleProperties<ModuleProperties>;
export {};
